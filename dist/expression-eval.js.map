{"version":3,"file":"expression-eval.js","sources":["../node_modules/jsep/build/jsep.js","../node_modules/expression-eval/index.js"],"sourcesContent":["//     JavaScript Expression Parser (JSEP) 0.3.3\r\n//     JSEP may be freely distributed under the MIT License\r\n//     http://jsep.from.so/\r\n\r\n/*global module: true, exports: true, console: true */\r\n(function (root) {\r\n\t'use strict';\r\n\t// Node Types\r\n\t// ----------\r\n\r\n\t// This is the full set of types that any JSEP node can be.\r\n\t// Store them here to save space when minified\r\n\tvar COMPOUND = 'Compound',\r\n\t\tIDENTIFIER = 'Identifier',\r\n\t\tMEMBER_EXP = 'MemberExpression',\r\n\t\tLITERAL = 'Literal',\r\n\t\tTHIS_EXP = 'ThisExpression',\r\n\t\tCALL_EXP = 'CallExpression',\r\n\t\tUNARY_EXP = 'UnaryExpression',\r\n\t\tBINARY_EXP = 'BinaryExpression',\r\n\t\tLOGICAL_EXP = 'LogicalExpression',\r\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\r\n\t\tARRAY_EXP = 'ArrayExpression',\r\n\r\n\t\tPERIOD_CODE = 46, // '.'\r\n\t\tCOMMA_CODE  = 44, // ','\r\n\t\tSQUOTE_CODE = 39, // single quote\r\n\t\tDQUOTE_CODE = 34, // double quotes\r\n\t\tOPAREN_CODE = 40, // (\r\n\t\tCPAREN_CODE = 41, // )\r\n\t\tOBRACK_CODE = 91, // [\r\n\t\tCBRACK_CODE = 93, // ]\r\n\t\tQUMARK_CODE = 63, // ?\r\n\t\tSEMCOL_CODE = 59, // ;\r\n\t\tCOLON_CODE  = 58, // :\r\n\r\n\t\tthrowError = function(message, index) {\r\n\t\t\tvar error = new Error(message + ' at character ' + index);\r\n\t\t\terror.index = index;\r\n\t\t\terror.description = message;\r\n\t\t\tthrow error;\r\n\t\t},\r\n\r\n\t// Operations\r\n\t// ----------\r\n\r\n\t// Set `t` to `true` to save space (when minified, not gzipped)\r\n\t\tt = true,\r\n\t// Use a quickly-accessible map to store all of the unary operators\r\n\t// Values are set to `true` (it really doesn't matter)\r\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\r\n\t// Also use a map for the binary operations but set their values to their\r\n\t// binary precedence for quick reference:\r\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\r\n\t\tbinary_ops = {\r\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\r\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\r\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7,\r\n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\r\n\t\t\t'+': 9, '-': 9,\r\n\t\t\t'*': 10, '/': 10, '%': 10\r\n\t\t},\r\n\t// Get return the longest key length of any object\r\n\t\tgetMaxKeyLen = function(obj) {\r\n\t\t\tvar max_len = 0, len;\r\n\t\t\tfor(var key in obj) {\r\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\r\n\t\t\t\t\tmax_len = len;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn max_len;\r\n\t\t},\r\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\r\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\r\n\t// Literals\r\n\t// ----------\r\n\t// Store the values to return for the various literals we may encounter\r\n\t\tliterals = {\r\n\t\t\t'true': true,\r\n\t\t\t'false': false,\r\n\t\t\t'null': null\r\n\t\t},\r\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\r\n\t\tthis_str = 'this',\r\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\r\n\t\tbinaryPrecedence = function(op_val) {\r\n\t\t\treturn binary_ops[op_val] || 0;\r\n\t\t},\r\n\t// Utility function (gets called from multiple places)\r\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\r\n\t\tcreateBinaryExpression = function (operator, left, right) {\r\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\r\n\t\t\treturn {\r\n\t\t\t\ttype: type,\r\n\t\t\t\toperator: operator,\r\n\t\t\t\tleft: left,\r\n\t\t\t\tright: right\r\n\t\t\t};\r\n\t\t},\r\n\t\t// `ch` is a character code in the next three functions\r\n\t\tisDecimalDigit = function(ch) {\r\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\r\n\t\t},\r\n\t\tisIdentifierStart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\t\tisIdentifierPart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n\t\t\t\t\t(ch >= 48 && ch <= 57) || // 0...9\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\r\n\t\t// Parsing\r\n\t\t// -------\r\n\t\t// `expr` is a string with the passed in expression\r\n\t\tjsep = function(expr) {\r\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\r\n\t\t\t// All of the gobbles below will modify `index` as we move along\r\n\t\t\tvar index = 0,\r\n\t\t\t\tcharAtFunc = expr.charAt,\r\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\r\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\r\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\r\n\t\t\t\tlength = expr.length,\r\n\r\n\t\t\t\t// Push `index` up to the next non-space character\r\n\t\t\t\tgobbleSpaces = function() {\r\n\t\t\t\t\tvar ch = exprICode(index);\r\n\t\t\t\t\t// space or tab\r\n\t\t\t\t\twhile(ch === 32 || ch === 9 || ch === 10 || ch === 13) {\r\n\t\t\t\t\t\tch = exprICode(++index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\r\n\t\t\t\tgobbleExpression = function() {\r\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\r\n\t\t\t\t\t\tconsequent, alternate;\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\r\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tconsequent = gobbleExpression();\r\n\t\t\t\t\t\tif(!consequent) {\r\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\talternate = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!alternate) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\r\n\t\t\t\t\t\t\t\ttest: test,\r\n\t\t\t\t\t\t\t\tconsequent: consequent,\r\n\t\t\t\t\t\t\t\talternate: alternate\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrowError('Expected :', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn test;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\r\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\r\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\r\n\t\t\t\t// then, return that binary operation\r\n\t\t\t\tgobbleBinaryOp = function() {\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tvar biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\r\n\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check)) {\r\n\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\treturn to_check;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// This function is responsible for gobbling an individual expression,\r\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\r\n\t\t\t\tgobbleBinaryExpression = function() {\r\n\t\t\t\t\tvar ch_i, node, biop, prec, stack, biop_info, left, right, i;\r\n\r\n\t\t\t\t\t// First, try to get the leftmost thing\r\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\r\n\t\t\t\t\tleft = gobbleToken();\r\n\t\t\t\t\tbiop = gobbleBinaryOp();\r\n\r\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\r\n\t\t\t\t\tif(!biop) {\r\n\t\t\t\t\t\treturn left;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\r\n\t\t\t\t\t// precedence structure\r\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\r\n\r\n\t\t\t\t\tright = gobbleToken();\r\n\t\t\t\t\tif(!right) {\r\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstack = [left, biop_info, right];\r\n\r\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\r\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\r\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\r\n\r\n\t\t\t\t\t\tif(prec === 0) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\r\n\r\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\r\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\r\n\t\t\t\t\t\t\tright = stack.pop();\r\n\t\t\t\t\t\t\tbiop = stack.pop().value;\r\n\t\t\t\t\t\t\tleft = stack.pop();\r\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\r\n\t\t\t\t\t\t\tstack.push(node);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnode = gobbleToken();\r\n\t\t\t\t\t\tif(!node) {\r\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstack.push(biop_info, node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ti = stack.length - 1;\r\n\t\t\t\t\tnode = stack[i];\r\n\t\t\t\t\twhile(i > 1) {\r\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\r\n\t\t\t\t\t\ti -= 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// An individual part of a binary expression:\r\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\r\n\t\t\t\tgobbleToken = function() {\r\n\t\t\t\t\tvar ch, to_check, tc_len;\r\n\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch = exprICode(index);\r\n\r\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\r\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\r\n\t\t\t\t\t\treturn gobbleNumericLiteral();\r\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\r\n\t\t\t\t\t\t// Single or double quotes\r\n\t\t\t\t\t\treturn gobbleStringLiteral();\r\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\r\n\t\t\t\t\t\treturn gobbleArray();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\r\n\t\t\t\t\t\ttc_len = to_check.length;\r\n\t\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check)) {\r\n\t\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\r\n\t\t\t\t\t\t\t\t\toperator: to_check,\r\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\r\n\t\t\t\t\t\t\t\t\tprefix: true\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\r\n\t\t\t\t\t\t\t// `foo`, `bar.baz`\r\n\t\t\t\t\t\t\treturn gobbleVariable();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\r\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\r\n\t\t\t\tgobbleNumericLiteral = function() {\r\n\t\t\t\t\tvar number = '', ch, chCode;\r\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\r\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tchCode = exprICode(index);\r\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\r\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\r\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\r\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\r\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\r\n\t\t\t\t\t\tthrowError('Unexpected period', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: parseFloat(number),\r\n\t\t\t\t\t\traw: number\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\r\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\r\n\t\t\t\tgobbleStringLiteral = function() {\r\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\tif(ch === quote) {\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if(ch === '\\\\') {\r\n\t\t\t\t\t\t\t// Check for all of the common escape codes\r\n\t\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\t\tswitch(ch) {\r\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\r\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\r\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\r\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\r\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\r\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\r\n\t\t\t\t\t\t\t\tdefault : str += ch;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstr += ch;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(!closed) {\r\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: str,\r\n\t\t\t\t\t\traw: quote + str + quote\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles only identifiers\r\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\r\n\t\t\t\t// Also, this function checks if that identifier is a literal:\r\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\r\n\t\t\t\tgobbleIdentifier = function() {\r\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\r\n\r\n\t\t\t\t\tif(isIdentifierStart(ch)) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprICode(index);\r\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tidentifier = expr.slice(start, index);\r\n\r\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\t\tvalue: literals[identifier],\r\n\t\t\t\t\t\t\traw: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if(identifier === this_str) {\r\n\t\t\t\t\t\treturn { type: THIS_EXP };\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: IDENTIFIER,\r\n\t\t\t\t\t\t\tname: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\r\n\t\t\t\t// or array literal. This function also assumes that the opening character\r\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\r\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\r\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\r\n\t\t\t\tgobbleArguments = function(termination) {\r\n\t\t\t\t\tvar ch_i, args = [], node, closed = false;\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnode = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\targs.push(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!closed) {\r\n\t\t\t\t\t\tthrowError('Expected ' + String.fromCharCode(termination), index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn args;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\r\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\r\n\t\t\t\t// It also gobbles function calls:\r\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\r\n\t\t\t\tgobbleVariable = function() {\r\n\t\t\t\t\tvar ch_i, node;\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tnode = gobbleGroup();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode = gobbleIdentifier();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: false,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: true,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\r\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\r\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\r\n\t\t\t\t\t\t\t\tcallee: node\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\r\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\r\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\r\n\t\t\t\t// then the expression probably doesn't have a `)`\r\n\t\t\t\tgobbleGroup = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\tvar node = gobbleExpression();\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unclosed (', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\r\n\t\t\t\t// and then tries to gobble the expressions as arguments.\r\n\t\t\t\tgobbleArray = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: ARRAY_EXP,\r\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\tnodes = [], ch_i, node;\r\n\r\n\t\t\twhile(index < length) {\r\n\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\r\n\t\t\t\t// separators\r\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\r\n\t\t\t\t\tindex++; // ignore separators\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Try to gobble each expression individually\r\n\t\t\t\t\tif((node = gobbleExpression())) {\r\n\t\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\r\n\t\t\t\t\t// the expression passed in probably has too much\r\n\t\t\t\t\t} else if(index < length) {\r\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If there's only one expression just try returning the expression\r\n\t\t\tif(nodes.length === 1) {\r\n\t\t\t\treturn nodes[0];\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: COMPOUND,\r\n\t\t\t\t\tbody: nodes\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t// To be filled in by the template\r\n\tjsep.version = '0.3.3';\r\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\r\n\r\n\t/**\r\n\t * @method jsep.addUnaryOp\r\n\t * @param {string} op_name The name of the unary op to add\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addUnaryOp = function(op_name) {\r\n\t\tmax_unop_len = Math.max(op_name.length, max_unop_len);\r\n\t\tunary_ops[op_name] = t; return this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addBinaryOp\r\n\t * @param {string} op_name The name of the binary op to add\r\n\t * @param {number} precedence The precedence of the binary op (can be a float)\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addBinaryOp = function(op_name, precedence) {\r\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\r\n\t\tbinary_ops[op_name] = precedence;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addLiteral\r\n\t * @param {string} literal_name The name of the literal to add\r\n\t * @param {*} literal_value The value of the literal\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addLiteral = function(literal_name, literal_value) {\r\n\t\tliterals[literal_name] = literal_value;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeUnaryOp\r\n\t * @param {string} op_name The name of the unary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeUnaryOp = function(op_name) {\r\n\t\tdelete unary_ops[op_name];\r\n\t\tif(op_name.length === max_unop_len) {\r\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllUnaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllUnaryOps = function() {\r\n\t\tunary_ops = {};\r\n\t\tmax_unop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeBinaryOp\r\n\t * @param {string} op_name The name of the binary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeBinaryOp = function(op_name) {\r\n\t\tdelete binary_ops[op_name];\r\n\t\tif(op_name.length === max_binop_len) {\r\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllBinaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllBinaryOps = function() {\r\n\t\tbinary_ops = {};\r\n\t\tmax_binop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeLiteral\r\n\t * @param {string} literal_name The name of the literal to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeLiteral = function(literal_name) {\r\n\t\tdelete literals[literal_name];\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllLiterals\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllLiterals = function() {\r\n\t\tliterals = {};\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// In desktop environments, have a way to restore the old value for `jsep`\r\n\tif (typeof exports === 'undefined') {\r\n\t\tvar old_jsep = root.jsep;\r\n\t\t// The star of the show! It's a function!\r\n\t\troot.jsep = jsep;\r\n\t\t// And a courteous function willing to move out of the way for other similarly-named objects!\r\n\t\tjsep.noConflict = function() {\r\n\t\t\tif(root.jsep === jsep) {\r\n\t\t\t\troot.jsep = old_jsep;\r\n\t\t\t}\r\n\t\t\treturn jsep;\r\n\t\t};\r\n\t} else {\r\n\t\t// In Node.JS environments\r\n\t\tif (typeof module !== 'undefined' && module.exports) {\r\n\t\t\texports = module.exports = jsep;\r\n\t\t} else {\r\n\t\t\texports.parse = jsep;\r\n\t\t}\r\n\t}\r\n}(this));\r\n","var jsep = require('jsep');\n\n/**\n * Evaluation code from JSEP project, under MIT License.\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\n */\n\nvar binops = {\n  '||':  function (a, b) { return a || b; },\n  '&&':  function (a, b) { return a && b; },\n  '|':   function (a, b) { return a | b; },\n  '^':   function (a, b) { return a ^ b; },\n  '&':   function (a, b) { return a & b; },\n  '==':  function (a, b) { return a == b; }, // jshint ignore:line\n  '!=':  function (a, b) { return a != b; }, // jshint ignore:line\n  '===': function (a, b) { return a === b; },\n  '!==': function (a, b) { return a !== b; },\n  '<':   function (a, b) { return a < b; },\n  '>':   function (a, b) { return a > b; },\n  '<=':  function (a, b) { return a <= b; },\n  '>=':  function (a, b) { return a >= b; },\n  '<<':  function (a, b) { return a << b; },\n  '>>':  function (a, b) { return a >> b; },\n  '>>>': function (a, b) { return a >>> b; },\n  '+':   function (a, b) { return a + b; },\n  '-':   function (a, b) { return a - b; },\n  '*':   function (a, b) { return a * b; },\n  '/':   function (a, b) { return a / b; },\n  '%':   function (a, b) { return a % b; }\n};\n\nvar unops = {\n  '-' :  function (a) { return -a; },\n  '+' :  function (a) { return a; },\n  '~' :  function (a) { return ~a; },\n  '!' :  function (a) { return !a; },\n};\n\nfunction evaluateArray ( list, context ) {\n  return list.map((v) => evaluate(v, context));\n}\n\nfunction evaluateMember ( node, context ) {\n  const object = evaluate(node.object, context);\n  if ( node.computed ) {\n    return [object, object[evaluate(node.property, context)]];\n  } else {\n    return [object, object[node.property.name]];\n  }\n}\n\nfunction evaluate ( node, context ) {\n\n  switch ( node.type ) {\n\n    case 'ArrayExpression':\n      return evaluateArray( node.elements, context );\n\n    case 'BinaryExpression':\n      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );\n\n    case 'CallExpression':\n      let caller, fn;\n      if (node.callee.type === 'MemberExpression') {\n        [ caller, fn ] = evaluateMember( node.callee, context );\n      } else {\n        fn = evaluate( node.callee, context );\n      }\n      if (typeof fn  !== 'function') return undefined;\n      return fn.apply( caller, evaluateArray( node.arguments, context ) );\n\n    case 'ConditionalExpression':\n      return evaluate( node.test, context )\n        ? evaluate( node.consequent, context )\n        : evaluate( node.alternate, context );\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression':\n      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );\n\n    case 'MemberExpression':\n      return evaluateMember(node, context)[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[ node.operator ]( evaluate( node.argument, context ) );\n\n    default:\n      return undefined;\n  }\n\n}\n\nfunction compile (expression) {\n  return evaluate.bind(null, jsep(expression));\n}\n\nmodule.exports = {\n  parse: jsep,\n  eval: evaluate,\n  compile: compile\n};\n"],"names":["this"],"mappings":"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"}